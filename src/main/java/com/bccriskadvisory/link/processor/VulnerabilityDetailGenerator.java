/**
 * Copyright (C) 2015 BCC Risk Advisory (info@bccriskadvisory.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.bccriskadvisory.link.processor;

import static com.google.common.base.Preconditions.checkNotNull;

import java.util.Collections;
import java.util.List;

import org.pegdown.PegDownProcessor;
import org.pegdown.ast.RootNode;

import com.bccriskadvisory.link.connector.EdgescanConnectionException;
import com.bccriskadvisory.link.connector.EdgescanV1Connector;
import com.bccriskadvisory.link.rest.edgescan.EdgescanResponse;
import com.bccriskadvisory.link.rest.edgescan.Vulnerability;
import com.bccriskadvisory.link.rest.edgescan.VulnerabilityDetails;
import com.bccriskadvisory.link.utility.AbstractLogSupported;
import com.google.common.base.CharMatcher;
import com.google.common.base.Joiner;
import com.google.common.collect.Lists;

public class VulnerabilityDetailGenerator extends AbstractLogSupported {

	private static final String LINE_BREAK = "\n----\n";
	private EdgescanV1Connector connector;
	private PegDownProcessor pegDownProcessor = new PegDownProcessor();
	
	public VulnerabilityDetailGenerator(EdgescanV1Connector connector) {
		this.connector = checkNotNull(connector, "Edgescan Connector");
	}
	
	public String getDetails(int vulnId) {
		final String externalLink = generateExternalLink(vulnId);
		
		EdgescanResponse response;
		try {
			response = connector.vulnerabilities().withId(vulnId).execute();
		} catch (EdgescanConnectionException e) {
			getLog().error("Unable to get vulnerability details for id " + vulnId, e);
			return externalLink;
		}
		
		if (response.getDetailedVulnerability() != null) {
			Vulnerability vulnerability = response.getDetailedVulnerability();
			List<String> convertedDetails = Lists.newArrayList(); 
			
			for (VulnerabilityDetails detail : vulnerability.getDetails()) {
				final String markdownDetail = detail.getSrc();
				RootNode parsed = pegDownProcessor.parseMarkdown(escapeMarkdown(markdownDetail).toCharArray());
				convertedDetails.add(new ConfluenceWikiMarkupSerializer().toWikiMarkup(parsed));
			}
			
			return Joiner.on(LINE_BREAK).join(convertedDetails) + LINE_BREAK + externalLink  ;
		} else {
			return externalLink;
		}
	}

	private String escapeMarkdown(final String markdownDetail) {
		final String intermediate = CharMatcher.is('}').replaceFrom(markdownDetail, "\\}");
		return CharMatcher.is('{').replaceFrom(intermediate, "\\{");
	}

	private String generateExternalLink(int vulnId) {
		final String vulnerabilityUrl = connector.vulnerabilityUrl(vulnId);
		
		return "The full details of this vulnerability can be found [here|" + vulnerabilityUrl + "].";
	}
}
