/**
 * Copyright (C) 2015 BCC Risk Advisory (info@bccriskadvisory.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.bccriskadvisory.link.processor;

import java.util.List;

import com.atlassian.jira.bc.ServiceResult;
import com.atlassian.jira.bc.issue.IssueService;
import com.atlassian.jira.bc.issue.IssueService.CreateValidationResult;
import com.atlassian.jira.bc.issue.IssueService.IssueResult;
import com.atlassian.jira.bc.issue.IssueService.TransitionValidationResult;
import com.atlassian.jira.bc.issue.IssueService.UpdateValidationResult;
import com.atlassian.jira.issue.IssueInputParameters;
import com.atlassian.jira.issue.MutableIssue;
import com.atlassian.jira.project.Project;
import com.atlassian.jira.user.ApplicationUser;
import com.atlassian.jira.util.ErrorCollection;
import com.atlassian.jira.util.SimpleErrorCollection;
import com.bccriskadvisory.jira.ao.projectlink.ProjectLink;
import com.bccriskadvisory.jira.ao.vulnerabilitylink.VulnerabilityLink;
import com.bccriskadvisory.jira.ao.vulnerabilitylink.VulnerabilityLinkService;
import com.bccriskadvisory.link.JiraPluginContext;
import com.bccriskadvisory.link.rest.edgescan.Vulnerability;
import com.bccriskadvisory.link.utility.AbstractLogSupported;
import com.opensymphony.workflow.loader.ActionDescriptor;

public class VulnerabilityImportProcessor extends AbstractLogSupported {

	private JiraPluginContext pluginContext;
	private IssueService issueService;
	private VulnerabilityLinkService vulnerabilityLinkService;
	private VulnerabilityDetailGenerator vulnerabilityDetailGenerator;
	
	private ApplicationUser user;
	private Project project;
	private ProjectLink link;
	
	private Vulnerability vulnerability;
	private VulnerabilityLink vulnerabilityLink;
	private MutableIssue linkedIssue;
	
	private boolean testModeOff;

	public VulnerabilityImportProcessor(JiraPluginContext pluginContext, VulnerabilityDetailGenerator vulnerabilityDetailGenerator, 
			ProjectLink link, ApplicationUser user, Project project, Vulnerability vulnerability) {
		this.pluginContext = pluginContext;
		this.issueService = pluginContext.getIssueService();
		this.vulnerabilityLinkService = pluginContext.getVulnerabilityLinkService();
		this.vulnerabilityDetailGenerator = vulnerabilityDetailGenerator;
		
		this.link = link;
		this.user = user;
		this.project = project;
		this.vulnerability = vulnerability;
	}
	
	public void init(boolean testMode) {
		this.testModeOff = !testMode;
		
		this.vulnerabilityLink = findVulnerabilityLink();
		
		if (vulnerabilityLink != null) {
			this.linkedIssue = findLinkedIssue();
		}
	}
	
	private VulnerabilityLink findVulnerabilityLink() {
		List<VulnerabilityLink> list = vulnerabilityLinkService.findBy("PROJECT_KEY = ? AND VULNERABILITY_ID = ?", project.getKey(), vulnerability.getId());
		if (list.isEmpty()) {
			return null;
		} else {
			return list.get(0);
		}
	}

	private MutableIssue findLinkedIssue() {
		IssueResult issueResult = issueService.getIssue(user, vulnerabilityLink.getIssueId());
		if (issueResult.isValid()) {
			return issueResult.getIssue();
		}
		return null;
	}

	public ServiceResult open() {
		IssueInputParameters parameters = createInputParameters(vulnerability);
		
		CreateValidationResult validationResult = issueService.validateCreate(user, parameters);
		
		if (validationResult.isValid()) {
			if (testModeOff) {
				IssueResult created = issueService.create(user, validationResult);
				linkedIssue = created.getIssue();
			}
		}
		
		return validationResult;
	}
	
	public void link() {
		if (testModeOff && linkedIssue != null) {
			final VulnerabilityLink vLink = new VulnerabilityLink();
			
			vLink.setIssueId(linkedIssue.getId());
			vLink.setIssueKey(linkedIssue.getKey());
			vLink.setProjectKey(project.getKey());
			vLink.setVulnerabilityId(vulnerability.getId());
			
			this.vulnerabilityLink = vulnerabilityLinkService.create(vLink);
		}
	}
	
	public ServiceResult update() {
		UpdateValidationResult validationResult = null;
		
		if (linkedIssue != null) {
			IssueInputParameters parameters = updateInputParameters(vulnerability);
			validationResult = issueService.validateUpdate(user, linkedIssue.getId(), parameters);
			
			if (validationResult.isValid() && testModeOff) {
				issueService.update(user, validationResult);
			}
		}
		
		return validationResult;
	}
	
	public ServiceResult close() {
		if (linkedIssue != null) {
			MutableIssue issue = linkedIssue;
			
			if (issue.getStatusObject().getId().equals(link.getCloseStatusId())) {
				getLog().info(String.format("Issue %s has already been set to the configured 'closed' status.", issue.getKey()));
				return new NoActionNeeded();
			}
			
			for (ActionDescriptor actionDescriptor : pluginContext.getIssueWorkflowManager().getAvailableActions(issue, user)) {
				String nextStatusId = pluginContext.getWorkflowManager().getNextStatusIdForAction(issue, actionDescriptor.getId());

				if (nextStatusId.equals(link.getCloseStatusId())) {
					return tryTransition(issue, actionDescriptor);
				}
			}
		}
		return null;
	}

	private ServiceResult tryTransition(MutableIssue issue, ActionDescriptor actionDescriptor) {
		TransitionValidationResult validationResult = 
				issueService.validateTransition(user, issue.getId(), actionDescriptor.getId(), issueService.newIssueInputParameters());

		if (validationResult.isValid() && testModeOff) {
			issueService.transition(user, validationResult);
		}
		
		return validationResult;
	}
	
	public void unlink() {
		if (testModeOff && vulnerabilityLink != null) {
			vulnerabilityLinkService.delete(vulnerabilityLink);
		}
	}
	
	private IssueInputParameters createInputParameters(Vulnerability vulnerability) {

		return updateInputParameters(vulnerability)
				.setProjectId(project.getId())
				.setSummary(vulnerability.getName() + " at location " + vulnerability.getLocation())
				.setDescription(vulnerabilityDetailGenerator.getDetails(vulnerability.getId()))
				.setStatusId(link.getOpenStatusId());
	}
	
	private IssueInputParameters updateInputParameters(Vulnerability vulnerability) {
		return issueService.newIssueInputParameters()
				.setIssueTypeId(link.getIssueTypeId())
				.setAssigneeId(user.getKey())
				.setReporterId(user.getKey())
				.setPriorityId(link.getMappedPriorityFromRisk(vulnerability.getRisk()));
	}

	public MutableIssue getLinkedIssue() {
		return linkedIssue;
	}
	
	public boolean isLinked() {
		return linkedIssue != null;
	}

	public void tidyDanglingLink() {
		if (vulnerabilityLink != null && linkedIssue == null) {
			//The issue linked to the vulnerability cannot be found, if the vulnerability is open a new 
			//issue will be created, but first we must delete the existing link.
			unlink();
		}
	}
	
	private class NoActionNeeded implements ServiceResult {

		@Override
		public ErrorCollection getErrorCollection() {
			return new SimpleErrorCollection();
		}

		@Override
		public boolean isValid() {
			return true;
		}
		
		
	}
}