/**
 * Copyright (C) 2015 BCC Risk Advisory (info@bccriskadvisory.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.bccriskadvisory.link.processor;

import static com.google.common.base.Preconditions.checkNotNull;

import java.util.List;
import java.util.Optional;

import com.atlassian.jira.bc.ServiceResult;
import com.atlassian.jira.bc.issue.IssueService;
import com.atlassian.jira.bc.issue.IssueService.CreateValidationResult;
import com.atlassian.jira.bc.issue.IssueService.IssueResult;
import com.atlassian.jira.bc.issue.IssueService.TransitionValidationResult;
import com.atlassian.jira.bc.issue.IssueService.UpdateValidationResult;
import com.atlassian.jira.bc.project.ProjectService.GetProjectResult;
import com.atlassian.jira.issue.IssueInputParameters;
import com.atlassian.jira.issue.MutableIssue;
import com.atlassian.jira.project.Project;
import com.atlassian.jira.user.ApplicationUser;
import com.atlassian.jira.user.util.UserManager;
import com.atlassian.jira.util.ErrorCollection;
import com.atlassian.jira.util.SimpleErrorCollection;
import com.bccriskadvisory.jira.ao.projectlink.ProjectLink;
import com.bccriskadvisory.jira.ao.vulnerabilitylink.VulnerabilityLink;
import com.bccriskadvisory.jira.ao.vulnerabilitylink.VulnerabilityLinkService;
import com.bccriskadvisory.link.JiraPluginContext;
import com.bccriskadvisory.link.rest.edgescan.Vulnerability;
import com.bccriskadvisory.link.utility.AbstractLogSupported;
import com.opensymphony.workflow.loader.ActionDescriptor;

public class VulnerabilityImportProcessor extends AbstractLogSupported {

	private JiraPluginContext pluginContext;
	private IssueService issueService;
	private VulnerabilityLinkService vulnerabilityLinkService;
	private VulnerabilityDetailGenerator vulnerabilityDetailGenerator;
	
	private ApplicationUser user;
	private Project project;
	private ProjectLink link;
	
	private Vulnerability vulnerability;
	private Optional<VulnerabilityLink> vulnerabilityLink;
	private Optional<MutableIssue> linkedIssue = Optional.empty();
	
	private boolean testModeOff;

	public VulnerabilityImportProcessor(JiraPluginContext pluginContext, ProjectLink link, Vulnerability vulnerability, 
			VulnerabilityDetailGenerator vulnerabilityDetailGenerator) {
		this.pluginContext = pluginContext;
		this.issueService = pluginContext.getIssueService();
		this.vulnerabilityLinkService = pluginContext.getVulnerabilityLinkService();
		this.vulnerabilityDetailGenerator = vulnerabilityDetailGenerator;
		
		this.link = link;
		this.vulnerability = vulnerability;
	}
	
	public void init(boolean testMode) {
		this.testModeOff = !testMode;
		final UserManager jiraUserManager = pluginContext.getUserManager().getJiraUserManager();
		this.user = checkNotNull(jiraUserManager.getUserByKey(link.getUserKey()), "Could not find user with key " + link.getUserKey());
		
		GetProjectResult result = pluginContext.getProjectService().getProjectByKey(user, link.getProjectKey());
		this.project = checkNotNull(result.getProject(), "Could not find project with key " + link.getProjectKey());
		
		this.vulnerabilityLink = findVulnerabilityLink();
		
		if (vulnerabilityLink.isPresent()) {
			this.linkedIssue = findLinkedIssue();
		}
	}
	
	private Optional<VulnerabilityLink> findVulnerabilityLink() {
		List<VulnerabilityLink> list = vulnerabilityLinkService.findBy("PROJECT_KEY = ? AND VULNERABILITY_ID = ?", project.getKey(), vulnerability.getId());
		if (list.isEmpty()) {
			return Optional.empty();
		} else {
			return Optional.of(list.get(0));
		}
	}

	private Optional<MutableIssue> findLinkedIssue() {
		IssueResult issueResult = issueService.getIssue(user, vulnerabilityLink.get().getIssueId());
		if (issueResult.isValid()) {
			return Optional.of(issueResult.getIssue());
		}
		return Optional.empty();
	}

	public Optional<ServiceResult> open() {
		IssueInputParameters parameters = createInputParameters(vulnerability);
		
		CreateValidationResult validationResult = issueService.validateCreate(user, parameters);
		
		if (validationResult.isValid()) {
			if (testModeOff) {
				IssueResult created = issueService.create(user, validationResult);
				linkedIssue = Optional.of(created.getIssue());
			}
		}
		
		return Optional.of(validationResult);
	}
	
	public void link() {
		if (testModeOff && linkedIssue.isPresent()) {
			final VulnerabilityLink vLink;
			
			if (this.vulnerabilityLink.isPresent()) {
				vLink = this.vulnerabilityLink.get();
			} else {
				vLink = new VulnerabilityLink();
			}
			
			vLink.setIssueId(linkedIssue.get().getId());
			vLink.setIssueKey(linkedIssue.get().getKey());
			vLink.setProjectKey(project.getKey());
			vLink.setVulnerabilityId(vulnerability.getId());
			
			if (this.vulnerabilityLink.isPresent()) {
				this.vulnerabilityLink = Optional.of(vulnerabilityLinkService.update(vLink));
			} else {
				this.vulnerabilityLink = Optional.of(vulnerabilityLinkService.create(vLink));
			}
		}
	}
	
	public Optional<ServiceResult> update() {
		UpdateValidationResult validationResult = null;
		
		if (linkedIssue.isPresent()) {
			IssueInputParameters parameters = updateInputParameters(vulnerability);
			validationResult = issueService.validateUpdate(user, linkedIssue.get().getId(), parameters);
			
			if (validationResult.isValid() && testModeOff) {
				issueService.update(user, validationResult);
			}
		}
		
		return Optional.ofNullable(validationResult);
	}
	
	public Optional<ServiceResult> close() {
		if (linkedIssue.isPresent()) {
			MutableIssue issue = linkedIssue.get();
			
			if (issue.getStatusObject().getId().equals(link.getCloseStatusId())) {
				getLog().info(String.format("Issue %s has already been set to the configured 'closed' status.", issue.getKey()));
				return Optional.of(new NoActionNeeded());
			}
			
			for (ActionDescriptor actionDescriptor : pluginContext.getIssueWorkflowManager().getAvailableActions(issue, user)) {
				String nextStatusId = pluginContext.getWorkflowManager().getNextStatusIdForAction(issue, actionDescriptor.getId());

				if (nextStatusId.equals(link.getCloseStatusId())) {
					return tryTransition(issue, actionDescriptor);
				}
			}
		}
		return Optional.empty();
	}

	private Optional<ServiceResult> tryTransition(MutableIssue issue, ActionDescriptor actionDescriptor) {
		TransitionValidationResult validationResult = 
				issueService.validateTransition(user, issue.getId(), actionDescriptor.getId(), issueService.newIssueInputParameters());

		if (validationResult.isValid() && testModeOff) {
			issueService.transition(user, validationResult);
		}
		
		return Optional.of(validationResult);
	}
	
	public void unlink() {
		if (testModeOff && vulnerabilityLink.isPresent()) {
			vulnerabilityLinkService.delete(vulnerabilityLink.get());
		}
	}
	
	private IssueInputParameters createInputParameters(Vulnerability vulnerability) {

		return issueService.newIssueInputParameters()
				.setProjectId(project.getId())
				.setIssueTypeId(link.getIssueTypeId())
				.setSummary(vulnerability.getName() + " at location " + vulnerability.getLocation())
				.setAssigneeId(user.getKey())
				.setReporterId(user.getKey())
				.setDescription(vulnerabilityDetailGenerator.getDetails(vulnerability.getId()))
				.setStatusId(link.getOpenStatusId())
				.setPriorityId(link.getMappedPriorityFromRisk(vulnerability.getRisk()));
	}
	
	private IssueInputParameters updateInputParameters(Vulnerability vulnerability) {
		return issueService.newIssueInputParameters()
				.setIssueTypeId(link.getIssueTypeId())
				.setAssigneeId(user.getKey())
				.setReporterId(user.getKey())
				.setStatusId(link.getOpenStatusId())
				.setPriorityId(link.getMappedPriorityFromRisk(vulnerability.getRisk()));
	}

	public Optional<MutableIssue> getLinkedIssue() {
		return linkedIssue;
	}
	
	public boolean isLinked() {
		return linkedIssue.isPresent();
	}

	public void tidyDanglingLink() {
		if (vulnerabilityLink.isPresent() && !linkedIssue.isPresent()) {
			//The issue linked to the vulnerability cannot be found, if the vulnerability is open a new 
			//issue will be created, but first we must delete the existing link.
			unlink();
		}
	}
	
	private class NoActionNeeded implements ServiceResult {

		@Override
		public ErrorCollection getErrorCollection() {
			return new SimpleErrorCollection();
		}

		@Override
		public boolean isValid() {
			return true;
		}
	}
}